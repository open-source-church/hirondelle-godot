@tool
extends RefCounted

# CLASS GOT AUTOGENERATED DON'T CHANGE MANUALLY. CHANGES CAN BE OVERWRITTEN EASILY.

class_name TwitchGetUserEmotesResponse

## 
var data: Array[Data]:
	set(val):
		data = val;
		changed_data["data"] = [];
		if data != null:
			for value in data:
				changed_data["data"].append(value.to_dict());
## A templated URL. Uses the values from the _id_, _format_, _scale_, and _theme\_mode_ fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote.        For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL](https://dev.twitch.tv/docs/irc/emotes#cdn-template) format.
var template: String:
	set(val):
		template = val;
		changed_data["template"] = template;
## Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.        For more information about pagination support, see [Twitch API Guide - Pagination](https://dev.twitch.tv/docs/api/guide#pagination).
var pagination: Pagination:
	set(val):
		pagination = val;
		if pagination != null:
			changed_data["pagination"] = pagination.to_dict();

var changed_data: Dictionary = {};

static func from_json(d: Dictionary) -> TwitchGetUserEmotesResponse:
	var result = TwitchGetUserEmotesResponse.new();
	if d.has("data") && d["data"] != null:
		for value in d["data"]:
			result.data.append(Data.from_json(value));
	if d.has("template") && d["template"] != null:
		result.template = d["template"];
	if d.has("pagination") && d["pagination"] != null:
		result.pagination = Pagination.from_json(d["pagination"]);
	return result;

func to_dict() -> Dictionary:
	return changed_data;

func to_json() -> String:
	return JSON.stringify(to_dict());

## 
class Data extends RefCounted:
	## An ID that uniquely identifies this emote.
	var id: String:
		set(val):
			id = val;
			changed_data["id"] = id;
	## The User ID of broadcaster whose channel is receiving the unban request.
	var name: String:
		set(val):
			name = val;
			changed_data["name"] = name;
	## The type of emote. The possible values are:       * **none** — No emote type was assigned to this emote. * **bitstier** — A Bits tier emote. * **follower** — A follower emote. * **subscriptions** — A subscriber emote. * **channelpoints** — An emote granted by using channel points. * **rewards** — An emote granted to the user through a special event. * **hypetrain** — An emote granted for participation in a Hype Train. * **prime** — An emote granted for linking an Amazon Prime account. * **turbo** — An emote granted for having Twitch Turbo. * **smilies** — Emoticons supported by Twitch. * **globals** — An emote accessible by everyone. * **owl2019** — Emotes related to Overwatch League 2019. * **twofactor** — Emotes granted by enabling two-factor authentication on an account. * **limitedtime** — Emotes that were granted for only a limited time.
	var emote_type: String:
		set(val):
			emote_type = val;
			changed_data["emote_type"] = emote_type;
	## An ID that identifies the emote set that the emote belongs to.
	var emote_set_id: String:
		set(val):
			emote_set_id = val;
			changed_data["emote_set_id"] = emote_set_id;
	## The ID of the broadcaster who owns the emote.
	var owner_id: String:
		set(val):
			owner_id = val;
			changed_data["owner_id"] = owner_id;
	## The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only static. But if the emote is available as a static PNG and an animated GIF, the array contains static and animated.       * **animated** — An animated GIF is available for this emote. * **static** — A static PNG file is available for this emote.
	var format: Array[String]:
		set(val):
			format = val;
			changed_data["format"] = [];
			if format != null:
				for value in format:
					changed_data["format"].append(value);
	## The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\.       * **1.0** — A small version (28px x 28px) is available. * **2.0** — A medium version (56px x 56px) is available. * **3.0** — A large version (112px x 112px) is available.
	var scale: Array[String]:
		set(val):
			scale = val;
			changed_data["scale"] = [];
			if scale != null:
				for value in scale:
					changed_data["scale"].append(value);
	## The background themes that the emote is available in.       * **dark** * **light**
	var theme_mode: Array[String]:
		set(val):
			theme_mode = val;
			changed_data["theme_mode"] = [];
			if theme_mode != null:
				for value in theme_mode:
					changed_data["theme_mode"].append(value);

	var changed_data: Dictionary = {};

	static func from_json(d: Dictionary) -> Data:
		var result = Data.new();
		if d.has("id") && d["id"] != null:
			result.id = d["id"];
		if d.has("name") && d["name"] != null:
			result.name = d["name"];
		if d.has("emote_type") && d["emote_type"] != null:
			result.emote_type = d["emote_type"];
		if d.has("emote_set_id") && d["emote_set_id"] != null:
			result.emote_set_id = d["emote_set_id"];
		if d.has("owner_id") && d["owner_id"] != null:
			result.owner_id = d["owner_id"];
		if d.has("format") && d["format"] != null:
			for value in d["format"]:
				result.format.append(value);
		if d.has("scale") && d["scale"] != null:
			for value in d["scale"]:
				result.scale.append(value);
		if d.has("theme_mode") && d["theme_mode"] != null:
			for value in d["theme_mode"]:
				result.theme_mode.append(value);
		return result;

	func to_dict() -> Dictionary:
		return changed_data;

	func to_json() -> String:
		return JSON.stringify(to_dict());

## Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.        For more information about pagination support, see [Twitch API Guide - Pagination](https://dev.twitch.tv/docs/api/guide#pagination).
class Pagination extends RefCounted:
	## The cursor used to get the next page of results. Use the cursor to set the request’s after query parameter.
	var cursor: String:
		set(val):
			cursor = val;
			changed_data["cursor"] = cursor;

	var changed_data: Dictionary = {};

	static func from_json(d: Dictionary) -> Pagination:
		var result = Pagination.new();
		if d.has("cursor") && d["cursor"] != null:
			result.cursor = d["cursor"];
		return result;

	func to_dict() -> Dictionary:
		return changed_data;

	func to_json() -> String:
		return JSON.stringify(to_dict());

